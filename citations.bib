@article{Abelson1998R5RS,
  author  = {
    Harold Abelson and R. Kent Dybvig and Christopher T. Haynes and Guillermo
    Juan Rozas and N. I. Adams IV and Daniel P. Friedman and Eugene E.
    Kohlbecker and Guy L. Steele Jr. and David H. Bartley and Robert H.
    Halstead Jr. and Don Oxley and Gerald J. Sussman and G. Brooks and Chris
    Hanson and Kent M. Pitman and Mitchell Wand
  },
  title   = {Revised Report on the Algorithmic Language Scheme},
  journal = {Higher-Order and Symbolic Computation},
  volume  = {11},
  number  = {1},
  pages   = {7--105},
  year    = {1998},
}

@article{Dybvig1990ANewApproach,
  author    = {R. Kent Dybvig and Robert Hieb},
  title     = {A New Approach to Procedures with Variable Arity},
  journal   = {Lisp Symb. Comput.},
  volume    = {3},
  number    = {3},
  pages     = {229--244},
  year      = {1990},
  publisher = {Kluwer Academic Publishers},
  address   = {Hingham, MA, USA},
  note      = {
    This paper proposes a ``list-free'' approach in Lisp to define
    variable-arity procedures via pattern matching on the spine of their
    argument lists.
  }
}

@article{Dybvig1993SyntacticAbstraction,
  author    = {R. Kent Dybvig and Robert Hieb and Carl Bruggeman},
  title     = {Syntactic Abstraction in Scheme},
  journal   = {LISP and Symbolic Computation},
  volume    = {5},
  number    = {4},
  pages     = {295-326},
  year      = {1993},
  publisher = {Kluwer Academic Publishers},
  keywords  = {Syntactic Abstraction, Macros, Program Transformation, Hygienic Macros},
  note      = {
    This paper describes a Scheme syntactic abstraction mechanism around the
    pattern/template-based \texttt{syntax-case}, a macro system underpinned by
    an efficient macro-expansion algorithm that guarantees intended hygienic
    but also allows intentional unhygienic macros defined in a general-purpose
    language.
  }
}

@incollection{Dybvig2007SyntacticAbstraction,
  author = {R. Kent Dybvig},
  title = {Syntactic Abstraction: The \texttt{syntax-case} Expander},
  booktitle = {Beautiful Code: Leading Programmers Explain How They Think},
  chapter = {25},
  pages = {407--428},
  editor = {Andy Oram and Greg Wilson},
  publisher = {O'Reilly and Associates},
  year = {2007},
  note = {
    This chapter provides a description and examples of the
    \texttt{syntax-case} expansion algorithm.
  }
}

@inproceedings{Erdweg2011SugarJ,
  author    = {
    Sebastian Erdweg and Lennart C.L. Kats and Tillmann Rendel and
    Christian K\"{a}stner and Klaus Ostermann and Eelco Visser
  },
  title     = {SugarJ: Library-Based Language Extensibility},
  booktitle = {
    Proceedings of the ACM international conference companion on Object
    oriented programming systems languages and applications companion
  },
  series    = {SPLASH '11},
  pages     = {187--188},
  year      = {2011},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {
    DSL Embedding, Language Extensibility, Language Workbench, Library
  },
}

@article{Hanson1981BlockNecessary,
  author  = {David R. Hanson},
  title   = {Is Block Structure Necessary?},
  journal = {Software: Practice and Experience},
  volume  = {11},
  number  = {8},
  pages   = {853-866},
  year    = {1981},
  note    = {
    This paper argues against block structures for modules.
  }
}

@incollection{Herzeel2008Reflection,
  title     = {Reflection for the Masses},
  author    = {Charlotte Herzeel and Pascal Costanza and Theo D’Hondt},
  booktitle = {Self-Sustaining Systems},
  pages     = {87--122},
  year      = {2008},
  publisher = {Springer}
  note      = {
    This paper presents refelection à la Smith in modern CS terms and the
    programming language Common Lisp.
  }
}

@article{McIlroy1960MacroExtensions,
  author    = {M. Douglas McIlroy},
  title     = {Macro Instruction Extensions of Compiler Languages},
  journal   = {Commun. ACM},
  volume    = {3},
  number    = {4},
  month     = {apr},
  pages     = {214--220},
  year      = {1960},
  publisher = {ACM},
  address   = {New York, NY, USA},
  note      = {
    This is probably the first paper on (textual) macros as a language
    extension mechanism.
  }
}

@inproceedings{Muchnick1980ComparisonOfLisp,
  author    = {Steven S. Muchnick and Uwe F. Pleban},
  title     = {A Semantic Comparison of LISP and SCHEME},
  booktitle = {
   Proceedings of the 1980 ACM conference on LISP and functional programming
  },
  series    = {LFP '80},
  pages     = {56--64},
  year      = {1980},
  publisher = {ACM},
  address   = {New York, NY, USA},
  note      = {
    This paper compares from a denotationally-semantic point of view four
    Lisp-family languages, including Lisp 1.0, Modern Lisp (fexpr Lisp), funarg
    Lisp and Scheme, and shows that Lisp 1.0 and Scheme are compositional while
    the other two are not.
  }
}

@incollection{Pfenning2001LogicalFrameworks,
  author    = {Frank Pfenning},
  title     = {Logical Frameworks},
  booktitle = {Handbook of Automated Reasoning},
  pages     = {1063--1147},
  year      = {2001},
  note      = {
    This chapter introduces the logical-framework way of formalizing a
    deduction system (a fragment of the intuitionistic first-order logic):
    specifying the abstract syntax of it, judgments and deductions in it;
    implementing it via logic meta-programming; and establishing meta-theories
    about it.
  }
}

@inproceedings{Schuman1970ExtensionMechanisms,
  author    = {Stephen A. Schuman and Philippe Jorrand },
  title     = {Definition Mechanisms in Extensible Programming Languages},
  booktitle = {
    Proceedings of the November 17-19, 1970, fall joint computer conference
  },
  series    = {AFIPS '70 (Fall)},
  pages     = {9--20},
  year      = {1970},
  publisher = {ACM},
  address   = {New York, NY, USA},
}

@inproceedings{Standish1975Extensibility,
  author    = {Thomas A. Standish},
  title     = {Extensibility in Programming Language Design},
  booktitle = {
    Proceedings of the May 19-22, 1975, national computer conference and
    exposition
  },
  series    = {AFIPS '75},
  pages     = {287--290},
  year      = {1975},
  publisher = {ACM},
  address   = {New York, NY, USA},
}

